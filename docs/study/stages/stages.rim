# study/stages
' rim
	Created by Leonard Pauli, 16 jul 2018
	Copyright © Leonard Pauli 2018

' inverse stage notation from js
	stage 0 is base - required for any parsing
	stage 1 is declarative - fundamental for use as declarative data structure/graphs
	.
	stage 2 is standard - minimal standard additions, helpers/sugar + makes logic possible
	stage 2-packages is default core additions // network, IO, etc
	.
	stage 3 is recommended additions // nicer syntax, etc
	stage 3-packages is recommended additions // extra math stuff, network nicer interface/helpers for use-cases/protocols not in core, etc
		have or not?
			would be neat to keep stage-2 to a minimal
			+ have most logic + std stuff in separate stage
				with clear notion that it's just recommended
					and therefore easily replacable
			though, eg. vs:
				- http (few uses, core functionality + explicit (not as dev-user-friendly), but std)
				- express
					became seen as the "recommended"
						early + in most tutorials, similar as to jQuery
					easier use, but not std
				- koa
					better imo
					made by same as behind express
					lower use, but slowly increasing
			using declarative... it should be possible to have:
				- explicit core (in stage 2??)
				- recommended implicit binding (in stage 3??)
				- that can easily be switched to another variant by user (stage 4..5??)
	.
	stage 4 is experimental // "best" community implementation from stage 5 selected
	stage 5 is experimental-community for plugins created by community but not yet incorporated into rim // multiple variation can exist, no guarantees, do not use in production (if you're not a maintainer)
	stage 6 is ideas without MVP experimental implementation
	.
	stage-X-plugins // for source-code -> internal
	stage-X-adapters // for internal -> external (eg. back to source-code, or different target)
	stage-X-packages/libs // eg. UI, DB, 

structure:
	singleline
	multiline

singleline
	stage-0-base // see stage-0
	stage-1-core // see stage-1

	stage-2-default
		import // a: import "./a" // want to avoid public/private/export, though if wanted, accomplish through linter using directives

		list-literal // [a, b] -> {}(a, b)
		
		identifier.strip{grouping} // a.("b", "c").d -> (a.b.d, a.c.d)
		identifier.strip{list} // a.["b", "c"].d -> a.b.c.d
		
		range{default} // ..
		range{up-to-excluding} // ..<
		range{step, stepperFn, start-values} // .., (1, 3)..6 (1, 3, 5), (1, (+ 3))..6 (1, 4), (4, 5, 2, 4)..6 (4, 5, 2, 4, 6)
		
		spread // ...
		stub // ...
		stub{defaultValue} // defaultValue...

	stage-3-experimental
		partial-application
		partial-application.hole // _
		partial-application.hole{spread} // ..._

		parent-accessor // @.0; module: @.-1 (last/top parent)
		
		meta-node // @ // current rim context + "reflection api"
		meta-accessor // @.property...

		meta-node{parser}
		meta-node{block-lexem} // inc. all sub tokens, ast info, source code location, etc
		meta-node{node-meta} // eg. input/output/inherits/properties lists, input->output modifier function, query function, etc

		query // a.{is Number, ...}
		
		type // Type, Number.Int, String, ...
		type{declaration} // a is String, a is String: 5
		type{validation}

		is{inherits} // a{b: 5}; c{is a}; c.b // 5
		is{check{MVP}} // a{b: 5}; c{is a}; c is a // true
		not{Boolean, is{check{MVP}} // returns "inverse"
		// isnt // or isn't
		// TODO: is, isn't vs =, ≠ ?

		range{infinite} // eg. ((1,3)..) to get all odd numbers

	stage-4-thoughs
		directive // @identifier, @(expression) // see meta-node and meta-accessor
		date-literal // 10:57, 16/7-2018@12:30.47.300am{UTC}
		number{suffix} // 10mm
		number{custom-formats/bases} // Number{base: 16}`4fA`, b16: Number{base: 16}; b16`4fA`
		
		exists
		empty // Empty ?

		label // colon, :label, (:label)
		label{destructuring} // import "@/components" (:{MyButton}) -> tmp: import "@/components"; MyButton: tmp.MyButton

		event // do, on
		event.state-update // do a.b = 7, or do a.b: 7?, explicit with =

		boolean.list.(or, and) // or returns the first non-empty value, does not convert to boolean
		boolean.list.or{match-mode} // eg. `or {is Number and > 5: it, is String: 10, else: 2}`
		conditional.(if, else)

		pipe, map // |, |>
		it, self, Self
		type-maybe-literal // Type? -> (Type or Empty)
		identifier.strip{implicit} // .a
		enum-implicit-access // a.b is Enum(x: 8, y: 7, z): .x

		string.raw{meta-syntax-highlighting-custom} // eg. for js`...` or Regex`[A-z]+`

		angle-bracket-context // what for? // <blabla>, can't contain > or <, if not directly wrapping other context, eg: <(hello < something)>, <{a is String}>

		type-conversion(as, from) // eg. "5" as Number, String from 5

	stage-4-default-libs
		math
			operators:
				+, -, *, /, =, ≠, =/= or !=, ≈, **, %, <, >, ≥, ≤, <= >=,
			functions:
				sin, cos, etc
				impure: do random
			types: Number.Rational, etc
			constants: pi, e, etc
			list extentions: avg, sum, min, max
		list
			functions:
				modifications: update/remove/add/insert etc // on copy
				see lodash, haskell libs, etc
			impure: do (functions.modifications{but not on copy or replace original})
		string
			count
			.0 ...
			.(2..4)
			.match...
		regex
			Regex`[A-z]+`
		...

	stage-4-packages
		image
		network/http
		view // ViewModuler
		data // DataModuler
		...


multiline
	stage-0-base // see stage-0
	stage-1-core // see stage-1

	stage-2-default
		comment.directive // ' @version: ...

	stage-3-experimental
		comment.headerPatterns // auto-detect author and copyright, etc
		comment.directive.documentation
