# study/syntax/singleline
' rim
	Created by Leonard Pauli, 14 jul 2018
	Copyright © Leonard Pauli 2017-2018

// see study/linting
// see singleline-extra
// TODO: see singleline-todo


# top-level line comment
// end-of-line comment
# // EOL-comment in top-level comment (EOL style but with top-level comment bg)
#text // lint `# text`
#a//b//c // lint `# a // b//c`
#// // lint remove empty comment
# // lint remove empty comment
// // lint remove empty comment


# identifier
identifier
identifier // EOL comment
identifier//EOL comment // to lint
a b // two identifiers
a b c d // many identifiers


# identifier.special
+
a + // normal + special identifier (suf)
+ a // normal + special identifier (pre)
a + b // normal + special identifier (in)
a+ // normal + special identifier (no space)


# identifier.boolean // not in parser, also, aliases
true
false
// yes: true; no: false // add aliases // TODO: though this should be done with true.rim.alias(yes)


# colon
: // alone
a: // no value
a: b // key-value, make a be a function of b // though same as setting a.0 to b? (right, and resetting a.(1..))
a b // pass b to the a function, return result (same as ((a.copy): b) (ie. setting a.0 to b and returning result of a's function without modifying a))

:: // double alone, another special identifier
a::b // another special identifier
a :: b // another special identifier

: b // no key (though could have meaning?, extend block with b (nah)?)
:b // to lint (though could have meaning?)
a:b // special operator / format (eg. see date/time) (though potetially warn)
a : b // special operator / format (eg. see date/time) (though potetially warn)


# parens // used to group parts at ast-level
( // lint add close (with question)
) // lint remove (with question)
() // shorthand for Empty, or just no value?
(a) // a // only visual diff
((a)) // to lint `(a)` // max one for visual, though possibly configurable?, or not even one?

(b) a // b a
(a b) c // (a b) c
a (b c) // a (b c)
a + (b + c) // a + b + c // paren makes no difference with associative operators?, except for visual, 
a (b (e f) // to lint (add ending paren) + with question
a ((b (c) d (e f))) // many nested

a () // same as `a()` same as `a` // fn `a.fn` (or something) vs fn value `a`
a (b) // a b
a(b) // similar to (`a (b)` same as `a b`)
a(b) c // a(b, c)
a (b) c // a(b(c)) // spacing makes a difference for grouping


# identifier.special.dot // dot notation
. // what? some parent/self or partial application hole?
. . // what?
. b // what?
a . b // what?

a. // what?
a.{b: c} // what?

.. // see identifier.special.range
... // see identifier.special.spread

# dot notation, identifier strip
a.b // [a, b], indicating b property on a
a.b.c // [a, b, c], indicating c property on b property on a
.b // with implicit base (usually a parent (recursive), or "it")
a.0 // [a, listitem 0], indicating list item with index 0 (first) of a
a.1 // [a, listitem 1], indicating list item with index 1 (second) of a
a.-1 // [a, listitem.fromEnd 0], indicating list item with index 0 (from end) (last) of a
a.-2 // [a, listitem.fromEnd 1], indicating list item with index 1 (from end) (second last) of a
a.1.2 // [a, listitem 1, listitem 2], dot is dot notation, not decimal point here
a.01 // lint `a.1` (overidable if wanted for lineup, autofixable)
a.(1).b // [a, listitem 1, b]; see "paren" and "paren list uses"
a."b".c // [a, b, c]
a.{} // what?
a.(+ 3) // partially applied function
a.(+ 3) 4 // [a, 7] (?)



# curly braces
} // alone close brace; expected to close brace block, traverse before and see if faulty indentation to auto fix, else ignore and warn
a } // eighter treat as alone close brace, or ignore + warn for unexpected (probably unintentional) extra close brace (if valid matching open not found)
{ // open brace at EOL; opens brace block (indentation inside block not as important for parsing, though lint fixed and without min indent, close brace might have issues correcting / not as effective?, close brace required)
{ a // unmatched line open brace; warn + lint add close (?)
{} // shorthand literal for Node
a {} // see `a b`
a: {} // see `a: b`
a{} // extend a's properties (not input as in `a {}`)

a.b // just accesses b property of a, doesn't create anything
a.b: true // set value on b property on a

a{b} // (a.b: b) if b exists or (a.b: {}) // not same as (a.b; a).-1
a{is b}
a{not b} // remove b proberty
{b: c} // similar to (a.b: c; a).-1


# number.(integer, decimal)
0
1
001.00200 // lint `1.00200` // trailing zeros for precision, leading are superfluous
-5 // negative nr, sure // no real diff between neg/pos nr, just relative to origo 
.0 // not a number, see dot notation
+2 // lint `+ 2`, possibly `(+ 2)` or ´(+) 2´ to mark that + is a function here, not a sign or part of the number


# identifier.special.range	
.. // range function infix operator? valid use?
(..) (3, 5) // (3, 4, 5)
3.. // infinite range; (negative list index (3..).-1 returns Infinity) (fn taking end `(3..) 5`)
..5 // infinite range; (positive list index (..5).0 returns -Infinity) (fn taking start `(..10) 5`)
(3..).1 // 4 // see "smart lazy evaluated"
(3..) 5 // (3, 4, 5) // fn taking end
(..5) 3 // (3, 4, 5) // fn taking start

0..3 // (0, 1, 2, 3)
0.. 3 // (0, 1, 2, 3) // lint `0..3` // it's an operator, so spacing doesn't matter
0 .. 3 // (0, 1, 2, 3) // lint `0..3`

0..<3 // (0, 1, 2) // ..< is range-up-to-excluding operator
0 ..< 3 // (0, 1, 2) // lint `0..<3`
0.. < 3 // "is an infinite range from 0 less than 3?" TODO: do a.0 < 3, treat it as a partially applied function, lint warn on comparing different types, or cast infinite range to positive Infinity?, probably last one, in which case, false (+Infinity isn't < 3)
0 .. < 3 // lint `(0..) < 3`

0..(+ 2) // partially applied function
0..(+ 2) 3 // 0..5

(10,9).. // infinite range w step -1 (or fn taking end)
(2.2,+0.2)..3 // 2.2,2.4,2.6,2.8,3 (+0.2 is stepper fn)
(2.2,(+ 0.2))..3 // same as above
(2.2,(- 0.2))..3 // 2.2,2.0,1.8,... (- 0.2 is stepper fn)
(2.2,-0.2).. // 2.2,-0.2,-2.6,... (-0.2 is a negative number, hence the step) // possibly ambiguous, ability to use / turn off lint rule that enforces (2.2,-0.2).. and (2.2,(-) 0.2).., etc?

0..x // ability to use variables/identifiers, it's just an operator
(firstValue,nextValueOrStepperFn)..lastValue // TODO: how to differentiate stepperFn from nextValue if it's a variable? ability to detect if partially applied or not
(firstValue,nextValue,nextValue2,nextValue3)..lastValue // what? -> (start.(0..<(-2)), ...start.(-2, -1)..lastValue)


# identifier.special.comma
, // alone
a, b // one
a, b, c // many
a ,b , c,d // to lint
a, , b // abundant, to lint (with question) (-> a, b) // or use a, Empty, b
a, (b, c) // should be same as (a, b), c // , is an associative operator, thereby parents doesn't matter
# identifier.special.comma // same effect as comma, though lint-preffered in block
; // semicolon
a; b

a: b, c // a: (b, c) or a: b; c


# braces, lists // sure?
(a, (b, c)) // a, b, c // parens only for ast grouping
c(a, b) // send a and b to c's input list (which, by default, also is the output list)
{}(a, b) // send a and b to a new empty node's input list
(a, {}(b, c)) // `a, {}(b, c)` same as `(a, g); g: (b, c)`.0 // list of two nodes, where second has two nodes in its list
(a, [b, c]) // `[x]` syntax sugar for `{}(x)`?


# identifier.special.spread // destructuring / spreading
... // spread operator, prefix
' concept: [a, ...[b, ...[e, f], c], d] -> [a, b, e, f, c, d]
	a: (c, d)
	b: (e, f)
	g: (a, ...b, ...a) // g: (a, (e, f), (c, d)) -> g: (a, e, f, c, d)
	acts on output list
	possible interpretations: spreadable:
		- properties content; {a: b, c, d: e} -> (a: b, c, d: e)
			`is` 
		- input list; add1(1..3) -> (1, 2, 3)
			add1(1..3).@.input -> (1, 2, 3)
		- output list; add1(1..3) -> (2, 3, 4) // though same by default (eg. a: (1..3))
			(add1(1..3), ...add1(1..3)) -> ({}(2, 3, 4), 2, 3, 4) // ie. .0.1 is .2

a... // lint `a ...` -> `a (...)`, passing the spread function to a
a ... // same as above

a ...b // send Spreaded{inner: b} to a (ie. ... only markes/wrapps it as "to be spreaded", it's up to the receiveing operators/functions to do something about it)
a...b // lint `a ...b`
a ... b // same as above

(a, ...{}(c, d)) // -> (a, Spreaded{inner: {}(c, d)}) -> ((,) (a, Spreaded{inner: {}(c, d)})) -> (a, c, d) // the comma function unwraps the output list of Spreaded.inner values
...a // spread output list inside to parent, see above (though here it is the "invisible block constructor" that does the work?)

{a, ...{b, c}, d} // lint warn if no relevant outputlist
{a, is {b, c}, d} // {a, b, c, d}
{a, is {b, is {e, f}, c}, d} // {a, b, e, f, c, d} // nested
